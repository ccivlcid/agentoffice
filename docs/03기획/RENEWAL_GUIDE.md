# HyperClaw 리뉴얼 가이드 (Vite + Express 유지)

> **전제**: 스택은 Vite + Express 유지. 기능·제품 아이디어를 단계적으로 도입해서 "같은 기술로 더 나은 제품"으로 만든다.

---

## 0. 방향성: 코딩 특화

**제품을 "코딩/개발 워크플로우 특화 AI 오케스트레이션"으로 재정의한다.** (일반적인 AI 오케스트레이션이 아니라, 개발·코드 워크플로우에 특화된 AI 오케스트레이션.)

### 포지셔닝

| 구분 | 내용 |
|------|------|
| **한 줄** | **코딩/개발 워크플로우 특화 AI 오케스트레이션** — 에이전트로 코드·리포지토리·개발 태스크를 관리 |
| **주 사용자** | 개발자, 팀 리드 (코드베이스·PR·빌드·리팩토링을 에이전트에 맡기는 사람) |
| **핵심 가치** | 태스크 = 개발 작업 단위, 에이전트 = 실행 주체, 결과 = diff/로그/아티팩트 |

### 강조할 것 (코딩 특화)

- **프로젝트/리포지토리 중심**: 작업은 항상 "어느 프로젝트(경로)"에서 이뤄진다. 프로젝트 선택·브랜치·경로 검증을 첫 화면/플로우에 배치.
- **태스크 = 개발 작업**: "버그 수정", "기능 구현", "리팩토링", "PR 리뷰" 등 타입/라벨을 코드 작업에 맞게. 상태는 Inbox → Planned → In Progress → Review(코드 리뷰) → Done.
- **코드 결과물 노출**: 터미널 로그, **diff 뷰**, 머지/디스카드 플로우를 웹에서 바로 확인. "무슨 코드가 바뀌었는지"가 첫 번째 정보.
- **스킬 = 코딩 컨텍스트**: 스킬을 "이 프로젝트/이 스택에서 쓰는 규칙·가이드"로. (예: Next.js 컨벤션, 테스트 규칙, API 스펙.)
- **CLI + 웹 연동**: 지시는 CLI, 상태·diff·설정·히스토리는 웹. 개발자 워크플로우에 CLI가 자연스럽게 들어가도록.

### 약화·선택화할 것

- **오피스 뷰 / 에이전트 시뮬레이션**: 유지해도 되지만 "부가 컨텐츠"로. 메인은 **태스크 보드 + 터미널 + diff**.
- **일반 메시지/공지**: 팀 공지보다 "태스크 코멘트·결과 요약·에이전트 리포트"에 초점. 채팅은 보조.
- **캐주얼 톤**: "엠파이어" 메타포는 유지 가능하되, **문구·UI 라벨은 개발자 친화적으로** (예: "Run" / "Merge" / "Discard" / "View diff").

### 코딩 특화 시 Phase 우선순위

1. **Phase 1 (API-First)** — 그대로 최우선. CLI·웹·추후 IDE 연동의 기반.
2. **Phase 3 (UX)** — "미니멀 커맨드센터"를 **개발자 대시보드**로 해석: TaskBoard + Terminal + Diff가 메인, 오피스/채팅은 서브.
3. **Phase 6 (CLI-First)** — 코딩 특화면 **CLI가 주 진입점**으로 올림. 웹은 모니터링·리뷰·설정.
4. **Phase 5 (스킬)** — "코딩 스킬"(프로젝트별 규칙·스택 가이드)로 재정의하면 우선순위 상승.
5. Phase 2 (이벤트), Phase 4 (멀티 테넌트) — 필요 시 그대로 진행.

### 메시지/문구 예시 (코딩 특화)

- **홈/대시보드**: "프로젝트별 작업 현황", "진행 중인 작업", "최근 diff".
- **태스크**: "Run", "View diff", "Merge to branch", "Discard changes".
- **에이전트**: "Assigned to …", "Running", "Review output".
- **스킬**: "Project skills", "Coding guidelines", "Load for this project".

---

## 1. 도입할 아이디어 요약

| 구분 | 아이디어 | 요약 |
|------|----------|------|
| **아키텍처** | API-First / 헤드리스 | 백엔드를 “진입점”으로, 프론트는 API 클라이언트 중 하나로 취급 |
| **아키텍처** | 이벤트 기반 | 태스크/에이전트 상태 변경을 이벤트로 발행, 구독 구조로 확장 용이하게 |
| **제품** | 멀티 테넌트(팀/워크스페이스) | 팀 단위로 에이전트·태스크·프로젝트 분리 (선택) |
| **제품** | 스킬/플러그인 마켓 | 스킬을 버전·의존성·공유 가능한 플러그인으로 (선택) |
| **UX** | 미니멀 커맨드센터 | 기존 “엠파이어” 감성 유지하되, 정보 밀도·가독성 강화 |
| **UX** | CLI-First + 웹 보조 | CLI가 주 인터페이스, 웹은 모니터링·설정·히스토리 |

이 문서는 **Vite + Express를 유지**한 채 위 아이디어를 **어떤 순서로, 어떻게** 넣을지 정리한 로드맵이다.

---

## 2. 단계별 로드맵

### Phase 1: API-First 정리 (우선 추천)

**목표**: 백엔드를 “진입점”으로 두고, 프론트는 그 위의 클라이언트로 명확히 분리.

- **백엔드**
  - API 버전·경로 규칙 정리: 예) `/api/v1/tasks`, `/api/v1/agents`.
  - 응답 형식 통일: `{ data?, error?, meta? }` 형태로 일관화.
  - OpenAPI(Swagger) 또는 간단한 `docs/api.md`로 스펙 문서화.
- **프론트**
  - `src/api.ts`를 **도메인별로 분리** (예: `src/api/tasks.ts`, `src/api/agents.ts`, `src/api/settings.ts`).
  - 공통 부분만 `src/api/client.ts`(baseURL, auth, fetch 래퍼)에 두고 나머지는 이걸 사용.
- **효과**: 나중에 모바일/CLI/다른 클라이언트를 붙이기 쉬워짐. “헤드리스” 기반 마련.

**진행 순서 예시**

1. 서버에 `/api/v1` prefix 및 공통 응답 래퍼 도입.
2. `src/api` 폴더 생성 후 `client.ts` + `tasks.ts` 등으로 기존 `api.ts` 분리.
3. `App.tsx` 등에서 `import * as api from './api'` → `import { getTasks } from './api/tasks'` 형태로 점진적 교체.

---

### Phase 2: 이벤트 기반 확장 (선택, 중기)

**목표**: 상태 변경을 “이벤트”로 발행해, 웹소켓·로그·알림이 같은 소스를 보게 함.

- **백엔드**
  - 핵심 액션(태스크 상태 변경, 에이전트 할당, 메시지 등) 시 **내부 이벤트 버스**에 이벤트 발행.
  - 기존 WebSocket은 “이벤트 구독자” 중 하나로 동작 (이벤트 → 브로드캐스트).
  - 필요 시 `EventEmitter` 또는 경량 큐로 구현.
- **프론트**
  - `useWebSocket`에서 오는 이벤트 타입을 `task_update`, `agent_status` 등으로 고정하고, 훅/컴포넌트에서 타입별로 처리.
- **효과**: 새 채널(이메일 알림, 슬랙, 로그 수집) 추가 시 서버 로직은 “이벤트 발행”만 늘리면 됨.

**진행 순서 예시**

1. 서버에 `server/events/bus.ts` 같은 단일 이벤트 버스 추가.
2. 기존 라우트에서 DB 갱신 후 `bus.emit('task.updated', payload)` 호출하도록 수정.
3. 기존 WebSocket 퍼블리시 로직을 이벤트 구독으로 이전.

---

### Phase 3: UX 리뉴얼 — 미니멀 커맨드센터

**목표**: “Cute but Efficient”은 유지하되, **가독성·정보 밀도**를 올려 “커맨드센터” 느낌 강화.

- **레이아웃**
  - 사이드바: 네비게이션 + 현재 컨텍스트(팀/프로젝트)만. 불필요한 장식 줄이기.
  - 메인: 카드/테이블 위주로 정리. 픽셀 에이전트는 “요약 영역”이나 “오피스 뷰”에만 집중.
- **컴포넌트**
  - 대형 컴포넌트(OfficeView, TaskBoard, SettingsPanel 등)를 **300줄 이하**로 쪼개기 (레이아웃 / 리스트 / 카드 / 폼으로 분리).
  - 공통 컴포넌트: `PageHeader`, `DataTable`, `StatusBadge`, `EmptyState` 등 추출해 재사용.
- **디자인 토큰**
  - `docs/DESIGN.md`의 empire 팔레트·태스크 상태 색은 유지. CSS 변수 또는 Tailwind 설정으로 한곳에서 관리.
- **효과**: 유지보수·신규 화면 추가가 쉬워지고, “프로덕션 툴” 같은 인상으로 정리됨.

**진행 순서 예시**

1. `src/components/ui/` 에 공통 컴포넌트 추출 (버튼, 뱃지, 카드, 테이블).
2. TaskBoard / SettingsPanel에서 “섹션 단위”로 분리 (예: TaskBoardFilters, TaskBoardColumns, TaskCard).
3. `DESIGN.md`에 “커맨드센터 레이아웃” 섹션 추가해 원칙만 명시.

---

### Phase 4: 멀티 테넌트(팀/워크스페이스) — 선택

**목표**: 팀(워크스페이스) 단위로 에이전트·태스크·프로젝트를 나누어 사용.

- **백엔드**
  - `workspaces` 또는 `teams` 테이블 추가. `tasks`, `agents`, `projects` 등에 `workspace_id` FK.
  - API에서 `workspace_id`는 세션/토큰에서 결정 (또는 쿼리 파라미터로 명시).
  - 기존 데이터는 “default” 워크스페이스로 마이그레이션.
- **프론트**
  - 상단/사이드바에 “현재 워크스페이스” 선택기. API 호출 시 항상 해당 워크스페이스 컨텍스트 포함.
- **효과**: 팀별로 사용처를 나누거나, SaaS처럼 “팀 단위 구독” 모델을 검토할 수 있음.

**진행 순서 예시**

1. DB 스키마 설계 (workspaces, FK 추가) 및 마이그레이션 스크립트.
2. 인증/세션에 `workspace_id` 포함. API 라우트에서 workspace 스코프 적용.
3. 프론트에 워크스페이스 선택 UI + API 클라이언트에 workspace 전달.

---

### Phase 5: 스킬/플러그인 마켓 — 선택 (장기)

**목표**: 스킬을 “설치·버전·의존성”이 있는 플러그인처럼 다룸.

- **백엔드**
  - 스킬 메타데이터 확장: `version`, `dependencies`, `repository` 등.
  - “스킬 레지스트리” API: 목록/검색/상세. (초기에는 로컬 JSON 또는 DB 테이블)
- **프론트**
  - Skills 라이브러리 화면에 “설치 가능 스킬 목록” + “설치/제거” 버튼.
  - 버전·의존성 표시 (선택).
- **효과**: 팀 간·커뮤니티 간 스킬 공유, 버전 관리가 가능해짐.

---

### Phase 6: CLI-First + 웹 보조

**목표**: CLI가 주 사용 경로, 웹은 모니터링·설정·히스토리용으로만 사용.

- **방향**
  - 기존 CLI 기능은 유지. “지시·실행”은 CLI, “상태 확인·설정·리포트”는 웹.
  - 웹 첫 화면을 “대시보드(요약)” + “설정” + “태스크 히스토리/리포트”로 단순화할 수 있음.
- **구현**
  - Phase 1 API-First가 되어 있으면, CLI와 웹이 같은 `/api/v1` 를 사용하도록 통일.
  - 웹에서 “빠른 액션”만 남기고, 복잡한 플로우는 CLI 안내 문구로 유도.
- **효과**: 파워유저는 CLI, 캐주얼 유저는 웹만 쓰는 구도 정리.

---

## 3. 권장 진행 순서 (한 줄 요약)

1. **Phase 1 (API-First)** → 먼저 진행. 나머지의 기반.
2. **Phase 3 (UX 미니멀)** → 대형 컴포넌트 분리와 함께 진행하면 유지보수에 유리.
3. **Phase 2 (이벤트)** → 새 채널/연동이 필요할 때 도입.
4. **Phase 4 (멀티 테넌트)** → 팀/워크스페이스 수요가 있을 때.
5. **Phase 5 (스킬 마켓)** → 스킬 공유·버전 수요가 있을 때.
6. **Phase 6 (CLI-First)** → 타겟 사용자(파워유저 vs 캐주얼) 정한 뒤 UX와 함께 결정.

---

## 4. Vite + Express 유지 시 체크리스트

- **Vite**: 그대로 사용. 필요 시 `src/api` 분리, 환경 변수(`VITE_API_BASE`)로 API 베이스 URL만 관리.
- **Express**: 기존 `server/` 구조 유지. `/api/v1` prefix, 공통 미들웨어( CORS, auth, error handler ), 라우트를 `server/modules/routes/` 등에 도메인별로 분리.
- **DB**: SQLite 유지. 스키마 변경 시 마이그레이션 스크립트만 추가.
- **실행**: 기존처럼 `pnpm dev` (또는 동일 스크립트)로 프론트+백 동시 실행 유지.

---

## 5. 다음 액션 제안

**방향성이 "코딩 특화"일 때:**

1. **당장**: Phase 1에서 `src/api/client.ts` + `src/api/tasks.ts` 등으로 `api.ts` 분리 계획 세우기.
2. **UX**: 메인 화면을 "태스크 보드 + 터미널 + diff" 중심으로 재구성. 오피스 뷰는 서브 메뉴 또는 접을 수 있는 영역으로.
3. **문구/라벨**: 앱 내 "Run", "View diff", "Merge", "Project" 등 개발자 친화 용어로 점진 교체 (i18n 반영).
4. **스킬**: 스킬 라이브러리를 "프로젝트 코딩 가이드" 관점으로 설명 추가 (DESIGN_SKILLS.md 또는 도움말).
5. **제품 방향**: 멀티 테넌트 필요 시 Phase 4, 스킬 공유(코딩 규칙 공유) 필요 시 Phase 5 순으로 검토.

원하면 Phase 1의 **폴더 구조 예시**나 **api 분리 예시 코드**를 이어서 작성해 줄 수 있다.
