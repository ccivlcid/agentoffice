/**
 * API client: auth, request helpers, idempotent POST.
 */

const base = '';
const SESSION_BOOTSTRAP_PATH = '/api/auth/session';
const API_AUTH_TOKEN_SESSION_KEY = 'claw_api_auth_token';
const POST_RETRY_LIMIT = 2;
const POST_TIMEOUT_MS = 12_000;
const POST_BACKOFF_BASE_MS = 250;
const POST_BACKOFF_MAX_MS = 2_000;

let runtimeApiAuthToken: string | undefined;
let sessionBootstrapPromise: Promise<boolean> | null = null;

import { ApiRequestError, isApiRequestError } from './errors';
export { ApiRequestError, isApiRequestError };

function normalizeApiAuthToken(raw: string | null | undefined): string {
  return typeof raw === 'string' ? raw.trim() : '';
}

function readStoredApiAuthToken(): string {
  if (runtimeApiAuthToken !== undefined) return runtimeApiAuthToken;
  if (typeof window === 'undefined') {
    runtimeApiAuthToken = '';
    return runtimeApiAuthToken;
  }
  try {
    runtimeApiAuthToken = normalizeApiAuthToken(
      window.sessionStorage.getItem(API_AUTH_TOKEN_SESSION_KEY),
    );
  } catch {
    runtimeApiAuthToken = '';
  }
  return runtimeApiAuthToken;
}

function writeStoredApiAuthToken(token: string): void {
  runtimeApiAuthToken = token;
  if (typeof window === 'undefined') return;
  try {
    if (token) {
      window.sessionStorage.setItem(API_AUTH_TOKEN_SESSION_KEY, token);
    } else {
      window.sessionStorage.removeItem(API_AUTH_TOKEN_SESSION_KEY);
    }
  } catch {
    // ignore
  }
}

function promptForApiAuthToken(hasExistingToken: boolean): string {
  if (typeof window === 'undefined') return '';
  const promptText = hasExistingToken
    ? 'Stored API token was rejected. Enter a new API token:'
    : 'Enter API token for this server:';
  return normalizeApiAuthToken(window.prompt(promptText));
}

export function setApiAuthToken(token?: string | null): void {
  writeStoredApiAuthToken(normalizeApiAuthToken(token));
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export function makeIdempotencyKey(prefix: string): string {
  const suffix =
    typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
      ? crypto.randomUUID()
      : `${Date.now()}-${Math.random().toString(16).slice(2)}`;
  return `${prefix}-${suffix}`;
}

function isAbortError(err: unknown): boolean {
  return (
    typeof err === 'object' &&
    err !== null &&
    'name' in err &&
    (err as { name?: string }).name === 'AbortError'
  );
}

function shouldRetryStatus(status: number): boolean {
  return status === 408 || status === 425 || status === 429 || status >= 500;
}

function backoffDelayMs(attempt: number): number {
  const exponential = Math.min(
    POST_BACKOFF_BASE_MS * 2 ** attempt,
    POST_BACKOFF_MAX_MS,
  );
  const jitter = Math.floor(Math.random() * 120);
  return exponential + jitter;
}

export function extractMessageId(payload: unknown): string {
  const maybePayload = payload as {
    id?: unknown;
    message?: { id?: unknown };
  } | null;
  if (maybePayload && typeof maybePayload.id === 'string' && maybePayload.id) {
    return maybePayload.id;
  }
  if (
    maybePayload?.message &&
    typeof maybePayload.message.id === 'string' &&
    maybePayload.message.id
  ) {
    return maybePayload.message.id;
  }
  throw new Error('message_id_missing');
}

function withAuthHeaders(init?: HeadersInit): Headers {
  const headers = new Headers(init);
  const runtimeToken = readStoredApiAuthToken();
  if (runtimeToken && !headers.has('authorization')) {
    headers.set('authorization', `Bearer ${runtimeToken}`);
  }
  return headers;
}

async function doBootstrapSession(promptOnUnauthorized: boolean): Promise<boolean> {
  try {
    const response = await fetch(`${base}${SESSION_BOOTSTRAP_PATH}`, {
      method: 'GET',
      headers: withAuthHeaders(),
      credentials: 'same-origin',
    });
    if (response.ok) return true;
    if (response.status === 401 && promptOnUnauthorized) {
      const nextToken = promptForApiAuthToken(Boolean(readStoredApiAuthToken()));
      if (nextToken) {
        writeStoredApiAuthToken(nextToken);
        return doBootstrapSession(false);
      }
    }
  } catch {
    // ignore
  }
  return false;
}

export async function bootstrapSession(options?: {
  promptOnUnauthorized?: boolean;
}): Promise<boolean> {
  const promptOnUnauthorized = options?.promptOnUnauthorized ?? true;
  if (!sessionBootstrapPromise) {
    sessionBootstrapPromise = doBootstrapSession(promptOnUnauthorized).finally(
      () => {
        sessionBootstrapPromise = null;
      },
    );
  }
  return sessionBootstrapPromise;
}

export async function request<T>(
  url: string,
  init?: RequestInit,
  canRetryAuth = true,
): Promise<T> {
  const headers = withAuthHeaders(init?.headers);
  const requestUrl = `${base}${url}`;
  const r = await fetch(requestUrl, {
    credentials: 'same-origin',
    ...init,
    headers,
  });
  if (r.status === 401 && canRetryAuth && url !== SESSION_BOOTSTRAP_PATH) {
    await bootstrapSession();
    return request<T>(url, init, false);
  }
  if (!r.ok) {
    const body = await r.json().catch(() => null);
    const errorCode = typeof body?.error === 'string' ? body.error : null;
    throw new ApiRequestError(
      errorCode ?? body?.message ?? `Request failed: ${r.status}`,
      {
        status: r.status,
        code: errorCode,
        details: body,
        url: requestUrl,
      },
    );
  }
  return r.json();
}

export function post(url: string, body?: unknown): Promise<unknown> {
  return request(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: body ? JSON.stringify(body) : undefined,
  });
}

export function patch(url: string, body: unknown): Promise<unknown> {
  return request(url, {
    method: 'PATCH',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body),
  });
}

export function put(url: string, body: unknown): Promise<unknown> {
  return request(url, {
    method: 'PUT',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body),
  });
}

export function del(url: string): Promise<unknown> {
  return request(url, { method: 'DELETE' });
}

export async function postWithIdempotency<T>(
  url: string,
  body: Record<string, unknown>,
  idempotencyKey: string,
  canRetryAuth = true,
): Promise<T> {
  const payload = { ...body, idempotency_key: idempotencyKey };
  const baseHeaders: HeadersInit = {
    'content-type': 'application/json',
    'x-idempotency-key': idempotencyKey,
  };

  for (let attempt = 0; attempt <= POST_RETRY_LIMIT; attempt++) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), POST_TIMEOUT_MS);

    try {
      const headers = withAuthHeaders(baseHeaders);
      const requestUrl = `${base}${url}`;
      const r = await fetch(requestUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
        signal: controller.signal,
        credentials: 'same-origin',
      });
      if (r.status === 401 && canRetryAuth && url !== SESSION_BOOTSTRAP_PATH) {
        await bootstrapSession();
        return postWithIdempotency<T>(url, body, idempotencyKey, false);
      }
      if (r.ok) {
        return r.json() as Promise<T>;
      }

      const responseBody = await r.json().catch(() => null);
      const errCode =
        typeof responseBody?.error === 'string' ? responseBody.error : null;
      const errMsg =
        errCode ?? responseBody?.message ?? `Request failed: ${r.status}`;
      if (attempt < POST_RETRY_LIMIT && shouldRetryStatus(r.status)) {
        await sleep(backoffDelayMs(attempt));
        continue;
      }
      throw new ApiRequestError(errMsg, {
        status: r.status,
        code: errCode,
        details: responseBody,
        url: requestUrl,
      });
    } catch (err) {
      const retryableNetworkError =
        err instanceof TypeError || isAbortError(err);
      if (attempt < POST_RETRY_LIMIT && retryableNetworkError) {
        await sleep(backoffDelayMs(attempt));
        continue;
      }
      throw err instanceof Error ? err : new Error(String(err));
    } finally {
      clearTimeout(timeout);
    }
  }

  throw new Error('unreachable_retry_loop');
}
